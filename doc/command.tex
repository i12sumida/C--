% 
% $Id$
%
\chapter{コマンドリファレンス}

UNIX や MacOS 上で動作する{\cmm}コンパイラの使用方法を解説します。

\section{{\cmmc}コマンド}

{\cmmc}コマンドは{\cmml}の{\tac}用コンパイラです。

\cmmc コマンドは、\cmml で記述されたプログラムを入力し、
\tac アセンブリ言語で記述したプログラムに変換します。
\cmmc コマンドの書式は次の通りです。

\begin{flushleft}
{\bf 形式 : }~~~\verb/c-- [-h] [-v] [-O0] [-O] [-O1] [-K] [<source file>]/
\end{flushleft}

引数に \cmml のソースプログラムファイルを指定した場合は、
指定されたファイルからソースプログラムを読み込みます。
ファイルが省略された場合は標準入力ストリームからソースプログラムを読み込みます。
どちらの場合もコンパイル結果は標準出力ストリームに出力します。
ソースプログラムファイルの拡張子は「\verb/.cmm/」にします。

\verb/-h/、\verb/-v/オプションは使用法メッセージを表示します。
\verb/-O0/オプションを指定すると、
ソースコード中の定数式をコンパイル時に計算したり、
実行されることがないプログラムの部分を削除したりする等の最適化をしません。
\verb/-O/、\verb/-O1/は最適化を促すオプションですが、
デフォルトで\verb/ON/になっているので指定する必要はありません。
\verb/-K/オプションを使うと、
関数入口へのスタックオーバーフロー検出コードの埋め込みが抑制されます。
\tacos のカーネルをコンパイルするときに使用するオプションです。

\cmmc コマンドは、\cl のプリプロセッサと組み合わせて次のように使用します。
コンパイル結果はリダイレクトを用いて拡張子「\verb/.s/」のファイルに出力します。

\begin{mylist}
\begin{verbatim}
$ cc -E -std=c99 -nostdinc -I/usr/local/cmmInclude \
-I/usr/local/cmmLib - < hello.cmm | c-- > hello.s
\end{verbatim}
\end{mylist}

この実行例は、OSX 10.11 の場合です。
OSX 10.11 の\verb/cpp/コマンドは、
\verb;//;コメントをうまく処理できないようです。
\verb/cc -E/コマンドを代用にするとうまく処理できます。
他の実行環境では、その環境にあう実行方法を試行錯誤する必要があるかもしれません。

%\cmm コンパイラはプリプロセッサと組み合わせた場合でも、
%エラーの発生箇所を正しく報告することができます。
%次の例はインクルードファイルの中にエラーがある場合の例です。
%
%\begin{mylist}
%\begin{verbatim}
%$ cat util.h 
%// util.h
%void printf(char[] fmt, ...);
%a;
%$ cat hello.cmm
%// hello.cmm
%#include "util.h"
%void main() {
%  printf("hello\n");
%}
%$ cpp -std=c99 hello.cmm | c-- > hello.s
%"util.h": 3 : 型がない
%$ 
%\end{verbatim}
%\end{mylist}

\section{{\vcmmc}コマンド}

仮想スタックマシンのニーモニックを出力する{\cmm}コンパイラです。

仮想スタックマシンのニーモニックは、
コンパイラ内部で用いている中間言語（\pageref{app:vm}ページ参照）と、
ほぼ一対一に対応します。
中間言語や仮想スタックマシンを学習したいときにこのコマンドを利用します。
{\vcmmc}コマンドの書式は次の通りです。

\begin{flushleft}
{\bf 形式 : }~~~\verb/vm-c-- [-h] [-v] [-O0] [-O] [-O1] [-K] [<source file>]/
\end{flushleft}

引数の意味は{\cmmc}コマンドと同様です。
次の実行例は変換結果を画面に表示しています。

\begin{mylist}
\begin{verbatim}
$ cc -E -std=c99 -nostdinc -I/usr/local/cmmInclude \
 - < hello.cmm | vm-c--
_stdin
        WS      1
_stdout
        WS      1
_stderr
        WS      1
.L1
        STRING  "hello,world\n"
_main
        ENTRY   0
        LDC     .L1
        ARG
        CALLF   1,_printf
        POP
        LDC     0
        MREG
        RET
\end{verbatim}
\end{mylist}

\section{{\ccmmc}コマンド}

{\cl}に変換して出力するトランスレータです。

出力された{\cl}は、
\verb;/user/local/cmmLib/; にインストールされた、
\verb;cfunc.hmm; や \verb;wrapper.c; を用いて、
UNIX や MacOS で実行できるようになります。

引数の意味は{\cmmc}コマンドと同様です。
次の実行例は変換結果を画面に表示しています。

\begin{mylist}
\begin{verbatim}
$ cc -E -std=c99 -nostdinc -I/usr/local/cmmInclude \
 -I/usr/local/cmmLib - < hello.cmm | c-c--
#include <stdio.h>
#define _cmm_str_L0 "hello,world\n"
int main(){
printf(_cmm_str_L0);
}
\end{verbatim}
\end{mylist}

次の実行例は変換結果を\verb/hello.c/ファイルに格納したあと、
{\cl}コンパイラでコンパイルして実行した例です。

\begin{mylist}
\begin{verbatim}
$ cc -E -std=c99 -nostdinc -I/usr/local/cmmInclude \
 -I/usr/local/cmmLib - < hello.cmm | c-c-- > hello.c
$ cc -o hello -Wno-parentheses-equality hello.c \
 /usr/local/cmmLib/wrapper.c
$ ./hello
hello,world
\end{verbatim}
\end{mylist}

