% 
% $Id$
%
\chapter{とりあえず使ってみよう}

\cmm プログラムは、 UNIX 上のクロス開発環境で機械語に変換され、
マイクロドライブに書き込まれます。
そのマイクロドライブを挿入した状態で \tac の電源を ON にすると、
\cmm プログラムが実行を開始します。
以下では、クロス開発環境を UNIX にインストールする手順と、
\cmm プログラムを入力して \tac 上で実行する手順を簡単に紹介します。

\section{クロス開発環境のインストール}

2009年4月現在、
\cmml の開発環境は UNIX 上の\cl で記述されたプログラム群として準備されています。
Windows 上の Cygwin 環境等の UNIX 互換環境でも動作するはずですが、
十分なテストが行われていません。
\cmml で記述したソースプログラムは、
UTF-8 を用いてエンコーディングされたテキストファイルを想定しています。

\cmml で記述したプログラムは本クロス開発環境により機械語に変換され、
FAT16 でフォーマットされたマイクロドライブに ``{\tt kernel.bin}'' と言う名前で
書き込まれ \tac で実行されます。
現在のところ \tac には OS が無いので、
OS に相当する``{\tt kernel.bin}''
ファイルにアプリケーションを書き込んで使用します。
\tac の IPL やブートプログラムはアプリケーションを OS として
読みだして実行します。

UNIX 上に以下で説明するプログラムをインストールして使用します。
これらのプログラムは、
配布される CD-ROM (または、USBメモリ) の
``{\tt Util-- }''フォルダに格納されています。

\subsection{\cmm コンパイラ}

\cmm コンパイラは \cmml で記述されたプログラムを
\tac アセンブリ言語で記述したプログラムに変換するプログラムです。
\cmm コンパイラは``{\tt Util--/C--}''フォルダに格納されています。
最新バージョンのフォルダで次のように実行してインストールします。
(UNIX の種類や設定によって操作方法が異なる場合があります。)

\begin{mylist}
\begin{verbatim}
$ make
cc -std=c99 -o c-- syntax.c lexical.c util.c
$ sudo make install
install -o root -g wheel -m 755 c-- /usr/local/bin
$
\end{verbatim}
\end{mylist}

これで、\cmm コンパイラが使用できるようになりました。
{\tt c--} と打ち込んで入力待ちになるか試してください。
入力待ちになるようならうまくインストールできています。
{\tt [Ctrl]-d} を入力して \cmm コンパイラを終了してください。

\begin{mylist}
\begin{verbatim}
$ c--
^D
$
\end{verbatim}
\end{mylist}

\subsection{アセンブラ}

アセンブラはアセンブリ言語で記述された \tac のプログラムを、
リロケータブルオブオブジェクトに変換するプログラムです。
リロケータブルオブジェクトは、
機械語プログラム、名前表、再配置情報表からなるファイルです。
この機械語プログラムは、
再配置情報表等を使用して、
後でロードアドレスが確定されます。
また、外部サブルーチンの呼び出しなどを未定義のままにしておくこともできます。
なお、リロケータブルオブジェクトファイルについては、
\pageref{app:oformat}ページ「\verb/.o/形式ファイル」で詳しく説明します。

アセンブラは``{\tt Util--/AS--}''フォルダに格納されています。
最新バージョンのフォルダで次のように実行してインストールします。

\begin{mylist}
\begin{verbatim}
$ make
cc -std=c99 -o as-- syntax.c lexical.c util.c
$ sudo make install
install -o root -g wheel -m 755 as-- /usr/local/bin
$
\end{verbatim}
\end{mylist}

これで、\tac アセンブラが使用できるようになりました。
{\tt as--} と打ち込んでアセンブラが起動することを確認してください。
次のような実行結果になるはずです。

\begin{mylist}
\begin{verbatim}
$ as--
使用方法 : as-- <file>
$
\end{verbatim}
\end{mylist}

\subsection{リンカ}

リンカは複数のリロケータブルオブジェクトを入力して、
一つのリロケータブルオブジェクトに結合するプログラムです。
リンカは``{\tt Util--/LD--}''フォルダに格納されています。
最新バージョンのフォルダで次のように実行してインストールします。

\begin{mylist}
\begin{verbatim}
$ make
cc -std=c99 -o ld-- ld.c
$ sudo make install
install -o root -g wheel -m 755 ld-- /usr/local/bin
$
\end{verbatim}
\end{mylist}

これで、\tac リンカが使用できるようになりました。
{\tt ld--} と打ち込んでリンカが起動することを確認してください。
次のような実行結果になるはずです。

\begin{mylist}
\begin{verbatim}
$ ld--
使用方法 : ld-- <outfile> <objfile>...
$
\end{verbatim}
\end{mylist}

\subsection{ローダ}

ローダはリロケータブルオブジェクトを入力して、
ロードアドレスが決定された機械語を出力します。
出力ファイルの形式については、
\pageref{app:bformat}ページ「\verb/.bin/形式ファイル」で詳しく説明します。

ローダは``{\tt Util--/OBJBIN--}''フォルダに格納されています。
最新バージョンのフォルダで次のように実行してインストールします。

\begin{mylist}
\begin{verbatim}
$ make
cc -std=c99 -o objbin-- objbin.c
$ sudo make install
install -o root -g wheel -m 755 objbin-- /usr/local/bin
$ 
\end{verbatim}
\end{mylist}

これで、\tac ローダが使用できるようになりました。
{\tt objbin--} と打ち込んでローダが起動することを確認してください。
次のような実行結果になるはずです。

\begin{mylist}
\begin{verbatim}
$ objbin--
使用方法 : objbin-- 0xTTTT <outfile> <objfile> [0xBBBB]
  0xTTTT : Text , Data セグメントのアドレス
  0xBBBB : BSS セグメントのアドレス
$
\end{verbatim}
\end{mylist}

\subsection{SIZE ユーティリティプログラム}

SIZE ユーティリティは、
リロケータブルオブジェクトのテキストセグメント、
初期化データセグメント、
非初期化データセグメントの大きさを知るために使用します。
OS の無い状態でアプリケーションを開発したり、
OS やブートローダ、IPL 等を開発したりするためにはメモリマップを手作業で
決定する必要があります。
SIZE ユーティリティは、メモリマップを決めるために役立ちます。

SIZE ユーティリティは``{\tt Util--/SIZE--}''フォルダに格納されています。
最新バージョンのフォルダで次のように実行してインストールします。

\begin{mylist}
\begin{verbatim}
$ make
cc -std=c99 -o size-- size.c
$ sudo make install
install -o root -g wheel -m 755 size-- /usr/local/bin
$ 
\end{verbatim}
\end{mylist}

これで、SIZE ユーティリティプログラムが使用できるようになりました。
{\tt size--} と打ち込んでプログラムが起動することを確認してください。
次のような実行結果になるはずです。

\begin{mylist}
\begin{verbatim}
$ size--
使用方法 : size-- <file name>
<file name> : TaC リロケータブル形式のファイル
$
\end{verbatim}
\end{mylist}

\section{マイクロドライブの準備}

\subsection{\tac のブート処理}

\tac は、
マイクロドライブに書き込まれたプログラムを読み出して自動的に実行を開始します。
電源が ON になると、
まず IPL プログラムが動作しマイクロドライブからブートプログラムを読み出します。
次に、ブートプログラムが動作しアプリケーションプログラムが読出されます。

IPL プログラムは ROM に内蔵されたは約 2kW の小さなプログラムです。
小さいのでマイクロドライブの構造を解析してファイルを読出すことはできません。
IPL はマイクロドライブの固定セクタに記録されたブートプログラムを
読み出して実行する簡単なプログラムになっています。

ブートプログラムは、
マイクロドライブの第23セクタ(第0セクタから数えた場合)からの
連続セクタに書き込まれます。
最近のほとんどのドライブは1トラック63セクタになっているので、
第1パーティションは第63セクタから始まります。
そのため、第23セクタから第62セクタまでの40セクタは通常使用されません。
IPL は、いつも第23セクタからブートプログラムを読み出します。

ブートプログラムは最大 10kW(20kB) の大きさまで許され、
IPL と比較すると複雑な機能を持つことが可能です。
そこで、ブートプログラムには
マイクロドライブの最初の FAT16 パーティションの構造を解析し、
それのルートディレクトリから``\verb/kernel.bin/''と言う名前のファイルを
見つけだし、読み込んで実行する機能を持たせることができました。

\tac で使用するマイクロドライブは 次のようなものである必要があります。

\begin{enumerate}
\item FAT16 でフォーマットされている。
\item パーティション外の固定セクタにブートプログラムが書き込まれている。
\item 最初の FAT16 パーティションのルートディレクトリに
``\verb/kernel.bin/''と言う名前のファイルが置いてある。
\end{enumerate}

\subsection{フォーマット}

マイクロドライブを Windows 等を用いて FAT16 フォーマットで初期化します。
Mac 等では自動的に FAT32 フォーマットが選択されることがあるようです。
FAT32 には対応していませんので、
必ず、FAT16 フォーマットで初期化するように気を付けてください。
この FAT16 パーティションのルートディレクトリに
``\verb/kernel.bin/''を書き込んで実行します。

\subsection{ブートプログラムの書き込み}

ブートプログラムは、
配布される CD-ROM (USBメモリ) の``{\tt Boot}''フォルダに
格納されています。
マイクロドライブを UNIX に接続した状態で、
このフォルダに移動し、
次のように操作することでブートプログラムがマイクロドライブに書き込まれます。

\begin{mylist}
\begin{verbatim}
$ make
as-- crt0.s
cpp -std=c99 boot.cmm | c-- > boot.s
as-- boot.s
cpp -std=c99 util.cmm | c-- > util.s
as-- util.s
ld-- boot crt0.o boot.o util.o > boot.sym
objbin-- 0xD000 boot.bin boot
dd if=boot.bin of=boot.512 bs=512 conv=sync
17+1 records in
18+0 records out
9216 bytes transferred in 0.000147 secs (62649442 bytes/sec)
$ sudo dd bs=512 seek=23 if=boot.512 of=/dev/da0
18+0 records in
18+0 records out
9216 bytes transferred in 0.959235 secs ( 9274 bytes/sec)
$
\end{verbatim}
\end{mylist}

最後の dd コマンドで指定する {\tt of=/dev/da0} の部分は使用するシステムによって
変化します。
マイクロドライブ全体(FAT16パーティションではない)を示す
デバイスファイル名を調べて書いてください。
また、使用する UNIX によって dd コマンドの使用方法や
使用前の準備方法が異なる場合がありますので、
それぞれの場合に適切な方法を調べて実行してください。

これで、マイクロドライブの第1パーティションのルートディレクトリから、
``\verb/kernel.bin/''と言う名前のファイルを読み出し実行を開始する
ブートプログラムがマイクロドライブに書き込まれました。

\section{\cmm プログラムの実行}

配布されるサンプルプログラムを \tac で実行してみましょう。

\subsection{プログラムの入力}

配布される CD-ROM (USBメモリ) の``{\tt Kernel}''フォルダに
いくつかのサンプルプログラムが格納されています。
最初は、８人の王妃問題の解法プログラム(Kernel/8queen)を
変更して動かしてみましょう。
\tabref{chap2:files}にフォルダ内のファイル一覧を示します。
``{\tt kernel.cmm}''をテキストエディタで書き換えます。
``{\tt util.h}'' に \cmml で使用できる関数の一覧があります。
サンプルプログラムを書き換えてみてください。

\begin{mytable}{tbhp}{{\tt Kernel/8queen}フォルダの内容}{chap2:files}
\begin{tabular}{ll} \hline
\multicolumn{1}{c}{ファイル名} & \multicolumn{1}{c}{内 容} \\ \hline
{\tt Makefile}
& make コマンドのためにコンパイルの手順が書いてあります。 \\
{\tt crt0.s}
& プログラムは、このアセンブリ言語ルーチンから実行を開始します。 \\
{\tt kernel.cmm}
& \cmml で記述したサンプルプログラムの本体です。 \\
{\tt util.cmm}
& {\tt kernel.cmm} から呼び出されるサブルーチンです。 \\
{\tt util.h}
& {\tt crt0.s} や {\tt util.cmm} で定義された関数のプロトタイプ宣言です。\\
\hline
\end{tabular}
\end{mytable}

\subsection{コンパイル}

``{\tt Kernel/8queen}''フォルダで make コマンドを実行すると
自動的にコンパイルされます。
以下に実行例を示します。
前の章でインストールしたプログラムが自動的に実行されていることが分かります。
また、cpp コマンドが実行されていることも分かります。
cpp コマンドは \cl 用のプリプロセッサ
(\verb/#include/ や \verb/#define/ の処理を担当するプログラム)です。
\cmml は専用のプリプロセッサを持たないので \cl 用のプリプロセッサを流用します。
コンパイルした結果、
``{\tt kernel.bin}''ファイルに {\tt 0x0000}番地にロードされる
機械語プログラムが作成されます。

\begin{mylist}
\begin{verbatim}
$ make
as-- crt0.s
cpp -std=c99 kernel.cmm | c-- > kernel.s
as-- kernel.s
cpp -std=c99 util.cmm | c-- > util.s
as-- util.s
ld-- kernel crt0.o kernel.o util.o > kernel.sym
objbin-- 0x0000 kernel.bin kernel
$
\end{verbatim}
\end{mylist}

\subsection{実行}

\tac で実行するために、
%FAT16でフォーマットされた
作成したプログラムをマイクロドライブのルートディレクトリに書き込みます。
この時、ファイル名は``{\tt kernel.bin}''でなければなりません。
次に、マイクロドライブを \tac にセットします。
\tac に VGA ディスプレイを接続して
\tac の電源を ON にするとプログラムが実行されます。
(サンプルプログラムのままなら、８人の王妃問題の解が次々とディスプレイに
表示されます。)
